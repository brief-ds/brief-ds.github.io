---
title: ARM64 function calls
layout: post
---

This article accompanies Lesson 10 Function Calls and Lesson 11 Stack Operations of the [ARM64 assembly tutorial](https://www.youtube.com/playlist?list=PLn_It163He32Ujm-l_czgEBhbJjOUgFhg) of LaurieWired.

When one function calls another one, the data in the old function is typically pushed into an area inside the computer memory called [stack](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)). When the new functions returns to the old function, the data in the old function is popped out from the stack. Only at one "end" of the stack, can programmer push in or pop out data. The register sp points to this "end" of the stack.

The stack only grows downward: sp decreases when content is pushed onto the stack and increases when content is popped out.

ARM64's stack is [16-bytes aligned](https://hrishim.github.io/llvl_prog1_book/stack.html), so 64-bit registers may get stored in pair. It is possible some gap in the stack is left. When an old function calls a new function, this new function must preserve the content of registers x19-x29 and sp, such that when the new function returns to the old one, the content in x19-x29 and sp is the same as right before the function call.

Refer to the [The first ARM64 assembly program](/2025/07/13/first-arm64-code.html) for how to call Linux (for ARM64) `exit()` to end execution.

## Function call with stack operation
For what `[sp, #-16]!` does etc, refer to the comment in the code below or [Aarch64 addressing mode](https://devblogs.microsoft.com/oldnewthing/20220728-00/?p=106912).

`func.s`:

```asm
.global _start

_start:
    mov x0, #1
    mov x1, #2

    stp x0, x1, [sp, #-16]!      // store pair x0 x1
                                 // store x0 to sp - 16
                                 // store x1 to sp - 8
                                 // and set sp to sp - 16
    bl add_nums
    ldp x0, x1, [sp], #16        // load pair x0 x1
                                 // load x0 from sp
                                 // load x1 from sp + 8
                                 // and set sp to sp + 16

    mov x8, #0x5d
    svc #0

add_nums:
    add x0, x0, x1
    ret
```

x0 after the `add_nums` call would store 3, but after the `ldp` call it was reset to the old value 1.

```sh
$ as -o func.o func.s
$ gcc -o func func.o -nostdlib -static
$ ./func; echo $?
1
```

## Generic prologue and clean-up code around function call
If one function calls another in nested way, the link register lr need be stored on the stack for each function call, along with the frame pointer fp. [Aarch64 code walkthrough](https://devblogs.microsoft.com/oldnewthing/20220829-00/?p=107066) gave some generic prologue and clean-up code around function call for example:

Prologue:

```asm
stp     x19, x20, [sp,#-0x20]!     // x19-x29 must be preserved
str     x21, [sp,#0x10]
stp     fp, lr, [sp,#-0x10]!
mov     fp, sp
```

Clean-up:

```asm
ldp     fp, lr, [sp], #0x10
ldr     x21, [sp, #0x10]
ldp     x19, x20, [sp], #0x20
ret
```

In the above example, after entry into a function, before executing any other code of it, the stack would be pushed

```
[empty 64-bit]
x21
x20
x19
lr
fp                <--- the new stack pointer sp
```

and grow downward: after the line `stp fp, lr, [sp,#-0x10]!`, the stack pointer sp would point to the bottom of the stack, an address storing the old frame pointer fp. Then the line `move fp, sp` sets the frame pointer fp to the current stack pointer sp. All this will be reversed right before exit of the same function.

## References
ARM64 assembly tutorial, LaurieWired, [https://www.youtube.com/playlist?list=PLn_It163He32Ujm-l_czgEBhbJjOUgFhg](https://www.youtube.com/playlist?list=PLn_It163He32Ujm-l_czgEBhbJjOUgFhg).

Introduction to Aarch64 architecture, 8. The Stack, [https://hrishim.github.io/llvl_prog1_book/stack.html](https://hrishim.github.io/llvl_prog1_book/stack.html).

Aarch64 part 3: addressing mode, [https://devblogs.microsoft.com/oldnewthing/20220728-00/?p=106912](https://devblogs.microsoft.com/oldnewthing/20220728-00/?p=106912).

Aarch64 part 24: code walkthrough, [https://devblogs.microsoft.com/oldnewthing/20220829-00/?p=107066](https://devblogs.microsoft.com/oldnewthing/20220829-00/?p=107066)

First ARM64 assembly program, [/2025/07/13/first-arm64-code.html](/2025/07/13/first-arm64-code.html).

Arm Compiler armasm User Guide. On [https://developer.arm.com](https://developer.arm.com), search for "armasm user guide". In the result list, find the latest version of "Arm Compiler armasm User Guide".
