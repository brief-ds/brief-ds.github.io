---
title: "RISC-V64 V extension for vector operations, and its flexibility"
layout: post
---

## Introduction
As in the [first post about RISC-V](/2025/08/11/first-riscv64-program.html), RISC-V would divide instruction set groups into base sets and extensions. V extension is for vector operations, workhorse of machine learning. It is very similar to ARM64 SVE (Scalable Vector Extension). Readers are encouraged to read the [counterpart post about ARM64 SVE](/2025/10/15/sve.html).

Again, the main reference is the RISC-V [**instruction set manual**](https://github.com/riscv/riscv-isa-manual), on which the README provides a link to the latest typeset [specification of unprivileged instructions](https://riscv.github.io/riscv-isa-manual/snapshot/unprivileged/). Section 30 is on the V extension. Appendix C provides multiple example V extension programs.

## RISC-V64 V extension
The V extension is for vector operations. The V extension requires a 64-bit integer operation base set: RV64E or RV64I.

The V extension defines 32 registers: v0-v31. The length of a vector register is set by the chip designer: a 128-bit vector register can hold four 32-bit numbers, a 256-bit vector register eight of them. A vector register can hold either multiple integers, or multiple floating-point numbers.

As with ARM64 SVE, the vector operation is agnostic of the length of a mathematical vector: the number of elements (numbers) in it. We just load as many of them as we can from the mathematical vector into the vector register(s), compute on the vector register(s), then proceed to the next batch of elements (numbers) in the mathematical vector, until we run out of elements to compute on.


## Example
If the `vmul` routine were more complex, stack operations to [preserve integer registers](/2025/08/11/first-riscv64-program.html) and [floating point registers](https://riscv.org/wp-content/uploads/2024/12/riscv-calling.pdf) may be necessary.

As in the [introductory post](/2025/08/11/first-riscv64-program.html), we first build the development toolchain on a x86-64 host: assembler, compiler, linker etc. for bare metal programming, which means when we use this toolchain to compile programs, the final executable file will need minimum support of the operating system (to manage memory etc), or any simulator to interpret the RISC-V instructions on x86-64.

Below we compute multiply two vectors element-wise.

`vmul.s`:

```asm
.global vmul

.text
vmul:
    # vmul(size_t n, int *x, int *y, int *z)
    #
    # multiplies two vectors element-wise.
    #
    # input: n, x, y
    # output: z
    #
    # n in register a0
    # x in register a1
    # y in register a2
    # z in register a3

vmul_loop:
    beq a0, zero, vmul_return     # if a0 == 0, go to vmul_return

    # given the remaining number of elements to process in a0,
    # return the maximum number of elements that can be handled
    # in one vector instruction.
    #
    # e32: each element (number) in the mathematical vector
    #      is 32-bit.
    #
    # m1:  grouping of 1 vector register.
    #
    # ta:  tail agnostic, when we are computing on the "tail"
    #      of the input vector, the last few elements in it.
    #      "ta" is usually a good setting. Leave it.
    #
    # ma:  mask agnostic, when a mask vector is present to indicate
    #      which elements in the vector register enter computation,
    #      which do not. "ma" is usually a good setting. Leave it.
    #
    # If the configuration is e32 and m1, and one vector register is 128-bit,
    #
    #   t0 = 4    if a0 >= 4
    #   t0 = a0   otherwise.
    #
    # If the configuration is e32 and m4, and one vector register is 128-bit,
    #
    #   t0 = 16   if a0 >= 16
    #   t0 = a0   otherwise.
    #
    vsetvli t0, a0, e32, m1, ta, ma

    vle32.v v0, (a1)        # load from memory into vector register
    vle32.v v2, (a2)
    vmul.vv v0, v0, v2      # integer multiplication element-wise
    vse32.v v0, (a3)        # store from vector register into memory

    sub a0, a0, t0          # having processed t0 numbers,
                            # decrement the number of elements to process

    slli t0, t0, 2          # t0 32-bit numbers take t0 x 4 bytes
                            # set t0 to t0 << 2 = t0 * 4

    add a1, a1, t0          # move the pointers to point to the next
    add a2, a2, t0          # element (32-bit number) to load or save
    add a3, a3, t0

    j vmul_loop             # jump to vmul_loop

vmul_return:
    mv a0, zero             # set return value
    ret
```

`main.c`:

```c
#include <stddef.h>
#include <stdio.h>

int vmul(size_t n, const int *x, const int *y, int *z);

int main() {
  size_t n = 6;
  int x[] = {1, 3, 4, 5, 6, 7};
  int y[] = {5, 6, 7, 8, 9, 10};
  int z[n];

  int k = vmul(n, x, y, z);

  for (size_t i = 0; i < n; ++i)
    printf("%i ", z[i]);
  printf("\n");

  return k;
}
```

To make the executable file,

```sh
$ /opt/rv64gcv/bin/riscv64-unknown-elf-as --march=rv64gcv -o vmul.o vmul.s
$ /opt/rv64gcv/bin/riscv64-unknown-elf-gcc -o main vmul.o main.c
```

As we built it with the toolchain for bare-metal programming, we can directly run it,

```sh
$ ./main
5 18 28 40 54 70
```

It can equally be run with a simulator that interprets RISC-V instructions on x86-64. Under Ubuntu Linux,

```sh
$ sudo apt install qemu-user
$ qemu-riscv64 -cpu rv64,v=on,vext_spec=v1.0,vlen=128 main
5 18 28 40 54 70
```

To adapt `vmul.s` for floating-point multiplication, change one single line:

```asm
    vfmul.vv v0, v0, v2     # floating-point  multiplication element-wise
```

and change accordingly `main.c`.

## The V extension's flexibility

## OpenBLAS kernels with RISC-V64 V extension
In [OpenBLAS](https://github.com/OpenMathLib/OpenBLAS) the linear algebra library, for example, for the general matrix-vector multiplication (gemv) routine, the files with `_rvv` or `_vector` in the file name use the RISC-V64 V extension:

```sh
kernel/riscv64/gemv_n.c
kernel/riscv64/gemv_n_rvv.c
kernel/riscv64/gemv_n_vector.c
kernel/riscv64/gemv_t.c
kernel/riscv64/gemv_t_rvv.c
kernel/riscv64/gemv_t_vector.c
kernel/riscv64/zgemv_n.c
kernel/riscv64/zgemv_n_rvv.c
kernel/riscv64/zgemv_n_vector.c
kernel/riscv64/zgemv_t.c
kernel/riscv64/zgemv_t_rvv.c
kernel/riscv64/zgemv_t_vector.c
```

## References
RISC-V instruction set manual, [https://github.com/riscv/riscv-isa-manual](https://github.com/riscv/riscv-isa-manual), the main reference for RISC-V

... from the above GitHub repository, a link to the typeset specification of unprivileged instructions, [https://riscv.github.io/riscv-isa-manual/snapshot/unprivileged/](https://riscv.github.io/riscv-isa-manual/snapshot/unprivileged/), with Section 30 on V extension, Appendix C providing multiple example V extension programs

Introduction to RISC-V, its integer registers, [/2025/08/11/first-riscv64-program.html](/2025/08/11/first-riscv64-program.html)

RISC-V calling convention, its floating-point registers, [https://riscv.org/wp-content/uploads/2024/12/riscv-calling.pdf](https://riscv.org/wp-content/uploads/2024/12/riscv-calling.pdf)

ARM64 SVE (Scalable Vector Extension), [/2025/10/15/sve.html](/2025/10/15/sve.html)

OpenBLAS, [https://github.com/OpenMathLib/OpenBLAS](https://github.com/OpenMathLib/OpenBLAS)
